/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "02.05.02"
}

/*
* This is the device type code for a z-wave customized thermostat with battery status, humidity, clock set, up-down tiles and icons. For individual customizations look at this thread:
* http://community.smartthings.com/t/z-wave-customized-thermostat-with-battery-humidity-clock-set-up-down-tiles-and-icons/7284
* Base code has been take from SmartThings as of Sept 2015
*
* Thermostat with Temperature, Humidity and Auto Time setting
*
* Taken from SmartThings base code, thanks to @minollo, enhanced and bugfixed by RBoy
* Changes Copyright RBoy, redistribution of any changes or modified code is not allowed without permission
*
* Change log:
* 2016-11-2 - Added ability to check for new code versions
* 2016-11-2 - Added ° symbol to the temperature
* 2016-10-19 - Added more fingerprints for Ct-30 variants
* 2016-9-19 - Added more fingerprints
* 2016-9-15 - Added support for v2 style fingerprints and check for defective z-wave module for CT-XXX which shows the wrong clock and adjust for it
* 2016-8-23 - Updated battery icon
* 2016-6-25 - Added more CT-101/CT-30 fingerprints and MSR codes for CT-101/CT-30
* 2016-5-15 - Notify use if timezone/location is missing in setup
* 2016-5-4 - Added CT-30 support for identification, added support for all CT-XXX models
* 2016-4-20 - Added DH version in setup page
* 2016-4-17 - Debug discovery code
* 2016-3-29 - Added CT-101 fingerprint
* 2016-3-28 - Added CT-30 fingerprint
* 2016-3-28 - Fixed bug with Fan showing 'null' in the summary line or not showing accurate state
* 2016-3-28 - Improved reliable of configure button to program thermostat parameters
* 2016-3-28 - Added fingerprints for CT-100 and ZTS-110 for automatic setup when adding new thermostats
* 2016-3-16 - Let system set temperature units (don't force to F)
* 2016-3-15 - Added support to configure reporting threshold, swing and calibration for CT-XXX and ZTS-110 thermostats
* 2016-2-10 - Improve polling handler when skipping polling
* 2016-2-6 - Bugfix for configure throwing error
* 2016-2-6 - Fixed refresh on configuration
* 2016-2-2 - Add initialization on settings update
* 2016-1-28 - Pressing Mode and Auto no longer goes into hunting mode, only one command at a time
* 2016-1-28 - Fix for Level Up/down for Android
* 2016-1-27 - Fix for ST iOS 2.0.8 release breaking Battery UI
* 2016-1-24 - Updated base code to 2016-1-24 (emergency heat is now emergencyHeat)
* 2016-1-24 - Bugfix for error on handling invalid / empty z-wave multiInstance command
* 2016-1-2 - Temporary workaround for ? showing up on Android 2.0.7
* 2015-12-6 - ST fixed the VALUE_CONTROL issues with the iOS release 2.0.5, reenabling it
* 2015-10-23 - VALUE_CONTROL causes the new ST app to crash, so disabled this feature until ST fixes their crappy app
* 2015-9-26 - Added color palette for Humidity
* 2015-9-23 - Updated layout and colors
* 2015-9-19 - Added support for MultiAttributeTiles
* 2015-8-7 - Fix for polling stopping when in battery save mode
* 2015-7-25 - Report change in state when operating state and fan state change
* 2015-7-22 - Updated to sync with ST base code
* 2015-7-12 - Fixed issue with battery and humidity not being reported
* 2015-7-9 - Added support fot battery save mode to reduce polling frequency to 30 minutes
* 2015-6-7 - Fix for Humidity not working (thanks @schettj)
* 2015-4-24 - Fix to supporting C and F for temp up/down
* 2015-2-10 - Added capability for battery
* 2015-2-3 - Updated base code to 2015-2-3, support for thermostatFanState attribute and Emergency Heat, added sliders for temp to make faster changes
* 2015-1-1 - Fix for battery update
* 2014-11-1 - Humidity, Battery update, Auto time setting
*
*/

/**
*  Z-Wave Thermostat
*
*  Copyright 2014 SmartThings
*
*  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
*  in compliance with the License. You may obtain a copy of the License at:
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
*  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
*  for the specific language governing permissions and limitations under the License.
*
*/ 
metadata {
    // Automatically generated. Make future change here.
    definition (name: "Z-Wave Thermostat with Temperature, Humidity and Auto Time setting", namespace: "rboy", author: "RBoy") {
        capability "Actuator"
        capability "Temperature Measurement"
        capability "Relative Humidity Measurement"
        capability "Thermostat"
        capability "Configuration"
        capability "Polling"
        capability "Sensor"
        capability "Refresh"
        capability "Battery"

        attribute "thermostatFanState", "string"
        attribute "thermStatus", "string"
        attribute "codeVersion", "string"
        attribute "dhName", "string"

        command "switchMode"
        command "switchFanMode"
        command "quickSetCool"
        command "quickSetHeat"
        command "refresh"
        command "heatLevelUp"
        command "heatLevelDown"
        command "coolLevelUp"
        command "coolLevelDown"
        command "levelUpDown"
        command "levelUp"
        command "levelDown"

        fingerprint deviceId: "0x08"
        fingerprint inClusters: "0x43,0x40,0x44,0x31"
        fingerprint inClusters: "0x20,0x31,0x40,0x42,0x43,0x44,0x45,0x47,0x70,0x72,0x80,0x81,0x85,0x86" // ZTS-110
        fingerprint inClusters: "0x20,0x81,0x87,0x72,0x31,0x40,0x44,0x43,0x42,0x86,0x70,0x80,0x88" // CT-30
        fingerprint inClusters: "0x20,0x87,0x72,0x31,0x40,0x44,0x43,0x42,0x86,0x70,0x80,0x88" // CT-30 (rebadged model from alarm company)
        fingerprint inClusters: "0x20,0x81,0x87,0x72,0x31,0x40,0x42,0x44,0x45,0x43,0x86,0x70,0x80,0x85,0x60" // CT-100, CT-101 (Lowe's version)
        fingerprint inClusters: "0x20,0x81,0x87,0x72,0x31,0x40,0x42,0x44,0x45,0x43,0x86,0x70,0x80,0x85,0x5D,0x60" // CT-101

        // New fingerprint format (MSR ==> mfr-prod-model)
        fingerprint type:"08" // Generic Thermostat
        fingerprint cc:"43,40,44,31" // Generic Thermostat
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,45,43,86,70,80,85,60", deviceJoinName:"CT-10X Z-Wave Thermostat" // Generic CT-100/101 Thermostat
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,45,43,86,70,80,85,60", mfr:"0098", prod:"6401", model:"0107", deviceJoinName:"CT-100 Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,45,43,86,70,80,85,60", mfr:"0098", prod:"6401", model:"0106", deviceJoinName:"CT-100 Z-Wave Vivint Thermostat" // Vivint
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,45,43,86,70,80,85,60", mfr:"0098", prod:"6501", model:"000C", deviceJoinName:"CT-101 Z-Wave Lowes Thermostat" // Lowes
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,45,43,86,70,80,85,5D,60", mfr:"0098", prod:"6501", model:"000C", deviceJoinName:"CT-101 Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,81,87,72,31,40,44,43,42,86,70,80,88", mfr:"0098", prod:"1E10", model:"0158", deviceJoinName:"CT-30 Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,87,72,31,40,44,43,42,86,70,80,88", mfr:"0098", prod:"0000", model:"0000", deviceJoinName:"CT-30 Rebadged Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,81,87,72,31,40,44,43,42,86,70,80,88", mfr:"0098", prod:"1E12", model:"015C", deviceJoinName:"CT-30e Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,31,40,42,43,44,45,47,70,72,80,81,85,86", mfr:"5254", prod:"0200", model:"8031", deviceJoinName:"ZTS-110 Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,45,43,86,70,80,85", mfr:"0098", prod:"1E12", model:"015E", deviceJoinName:"CT-30 Generic Rev C1 Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,43,86", mfr:"0098", prod:"0001", model:"001E", deviceJoinName:"APX CT-30 Z-Wave Thermostat"
    }

    // simulator metadata
    simulator {
        status "off"			: "command: 4003, payload: 00"
        status "heat"			: "command: 4003, payload: 01"
        status "cool"			: "command: 4003, payload: 02"
        status "auto"			: "command: 4003, payload: 03"
        status "emergencyHeat"	: "command: 4003, payload: 04"

        status "fanAuto"		: "command: 4403, payload: 00"
        status "fanOn"			: "command: 4403, payload: 01"
        status "fanCirculate"	: "command: 4403, payload: 06"

        status "heat 60"        : "command: 4303, payload: 01 09 3C"
        status "heat 68"        : "command: 4303, payload: 01 09 44"
        status "heat 72"        : "command: 4303, payload: 01 09 48"

        status "cool 72"        : "command: 4303, payload: 02 09 48"
        status "cool 76"        : "command: 4303, payload: 02 09 4C"
        status "cool 80"        : "command: 4303, payload: 02 09 50"

        status "temp 58"        : "command: 3105, payload: 01 2A 02 44"
        status "temp 62"        : "command: 3105, payload: 01 2A 02 6C"
        status "temp 70"        : "command: 3105, payload: 01 2A 02 BC"
        status "temp 74"        : "command: 3105, payload: 01 2A 02 E4"
        status "temp 78"        : "command: 3105, payload: 01 2A 03 0C"
        status "temp 82"        : "command: 3105, payload: 01 2A 03 34"

        status "idle"			: "command: 4203, payload: 00"
        status "heating"		: "command: 4203, payload: 01"
        status "cooling"		: "command: 4203, payload: 02"
        status "fan only"		: "command: 4203, payload: 03"
        status "pending heat"	: "command: 4203, payload: 04"
        status "pending cool"	: "command: 4203, payload: 05"
        status "vent economizer": "command: 4203, payload: 06"

        // reply messages
        reply "2502": "command: 2503, payload: FF"
    }

    preferences {
        input title: "", description: "Z-Wave Thermostat Device Handler v${clientVersion()}", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input "batterySaveMode", "bool", title: "Save Thermostat Battery", description: "Enable this to reduce polling frequency to once in 30 minutes to save thermostat battery", required: true, displayDuringSetup: true
        input title: "", description: "This section is used to configure the CT-XXX thermostats (CT30/CT32/CT50/CT80/CT100/CT101/CT110)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input "autoTempDiffCT", "enum", title: "Temperature Change Reporting Threshold", description: "Set the temperature change reporting threshold", multiple: false, defaultValue: "1.0°F", options: ["Disabled","0.5°F","1.0°F","1.5°F","2.0°F"], required: false, displayDuringSetup: true
        input "swingCT", "enum", title: "Temperature Swing", description: "Set the temperature swing threshold", multiple: false, defaultValue: "1.0°F", options: ["0.5°F","1.0°F","1.5°F","2.0°F","2.5°F","3.0°F","3.5°F","4.0°F"], required: false, displayDuringSetup: true
        input title: "", description: "This section is used to configure parameters for the ZTS-110 thermostat", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input "autoTempDiffZTS", "enum", title: "Temperature Change Reporting Threshold", description: "Set the temperature change reporting threshold", multiple: false, defaultValue: "4.0°F", options: ["Disabled","1.0°F","2.0°F","3.0°F","4.0°F","5.0°F","6.0°F","7.0°F","8.0°F"], required: false, displayDuringSetup: true
        input "swingZTS", "enum", title: "Temperature Swing", description: "Set the temperature swing threshold", multiple: false, defaultValue: "2.0°F", options: ["1.0°F","2.0°F","3.0°F","4.0°F"], required: false, displayDuringSetup: true
        input "tempCalibrationZTS", "enum", title: "Temperature Correction", description: "Set the temperature calibration", multiple: false, defaultValue: "0°F", options: ["-10°F","-9°F","-8°F","-7°F","-6°F","-5°F","-4°F","-3°F","-2°F","-1°F","0°F","1°F","2°F","3°F","4°F","5°F","6°F","7°F","8°F","9°F","10°F"], required: false, displayDuringSetup: true
    }

    tiles(scale: 2) {
        multiAttributeTile(name:"summary", type: "thermostat", width: 6, height: 4){
            tileAttribute ("device.temperature", key: "PRIMARY_CONTROL") {
                attributeState("temperature", label:'${currentValue}°',
                               backgroundColors:[
                                   [value: 31, color: "#153591"],
                                   [value: 44, color: "#1e9cbb"],
                                   [value: 59, color: "#90d2a7"],
                                   [value: 74, color: "#44b621"],
                                   [value: 84, color: "#f1d801"],
                                   [value: 95, color: "#d04e00"],
                                   [value: 96, color: "#bc2323"]
                               ]
                              )
            }
            tileAttribute ("device.thermStatus", key: "SECONDARY_CONTROL") {
                attributeState "thermStatus", label:'${currentValue}'
            }
            tileAttribute ("device.level", key: "VALUE_CONTROL") {
                attributeState "default", action: "levelUpDown"
                attributeState("VALUE_UP", action: "levelUp")
                attributeState("VALUE_DOWN", action: "levelDown")
            }
            tileAttribute("device.thermostatOperatingState", key: "OPERATING_STATE") {
                attributeState("idle", backgroundColor:"#44b621")
                attributeState("heating", backgroundColor:"#ffa81e")
                attributeState("cooling", backgroundColor:"#269bd2")
            }
            tileAttribute("device.thermostatMode", key: "THERMOSTAT_MODE") {
                attributeState("off", label:'${name}')
                attributeState("heat", label:'${name}')
                attributeState("cool", label:'${name}')
                attributeState("auto", label:'${name}')
            }
            /*tileAttribute("device.heatingSetpoint", key: "HEATING_SETPOINT") {
attributeState("default", label:'${currentValue}')
}
tileAttribute("device.coolingSetpoint", key: "COOLING_SETPOINT") {
attributeState("default", label:'${currentValue}')
}*/
        }
        valueTile("temperature", "device.temperature", width: 4, height: 4) {
            state("temperature", label:'${currentValue}°',
                  backgroundColors:[
                      [value: 31, color: "#153591"],
                      [value: 44, color: "#1e9cbb"],
                      [value: 59, color: "#90d2a7"],
                      [value: 74, color: "#44b621"],
                      [value: 84, color: "#f1d801"],
                      [value: 95, color: "#d04e00"],
                      [value: 96, color: "#bc2323"]
                  ]
                 )
        }
        standardTile("mode", "device.thermostatMode", width: 2, height: 2, inactiveLabel: false, canChangeIcon: false) {
            state "off", label:'Off', action:"switchMode", nextState:"...", icon: "st.Outdoor.outdoor19"
            state "heat", label:'Heat', action:"switchMode", nextState:"...", icon: "st.Weather.weather14", backgroundColor: '#E14902'
            state "cool", label:'Cool', action:"switchMode", nextState:"...", icon: "st.Weather.weather7", backgroundColor: '#003CEC'
            state "auto", label:'Auto', action:"switchMode", nextState:"...", icon: "st.Home.home1"
            state "emergencyHeat", label:'Emergency Heat', action:"switchMode", nextState:"...", icon: "st.Weather.weather2", backgroundColor: '#E11102'
            state "...", label: "...", nextState:"..."
        }
        standardTile("fanMode", "device.thermostatFanMode", width: 2, height: 2, inactiveLabel: false, canChangeIcon: false) {
            state "fanAuto", label:'Auto', action:"switchFanMode", nextState:"...", icon: "st.Appliances.appliances11"
            state "fanOn", label:'On', action:"switchFanMode", nextState:"...", icon: "st.Appliances.appliances11", backgroundColor: '#02E181'
            state "fanCirculate", label:'Circulate', action:"switchFanMode", nextState:"...", icon: "st.Appliances.appliances11", backgroundColor: '#02D2E1'
            state "...", label: "...", nextState:"..."
        }
        controlTile("heatSliderControl", "device.heatingSetpoint", "slider", width: 4, height: 1, inactiveLabel: false) {
            state "setHeatingSetpoint", action:"quickSetHeat", backgroundColor:"#d04e00"
        }
        valueTile("heatingSetpoint", "device.heatingSetpoint", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "heat", label:'${currentValue}°', backgroundColor: '#E14902'
        }
        controlTile("coolSliderControl", "device.coolingSetpoint", "slider", width: 4, height: 1, inactiveLabel: false) {
            state "setCoolingSetpoint", action:"quickSetCool", backgroundColor: "#1e9cbb"
        }
        valueTile("coolingSetpoint", "device.coolingSetpoint", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "cool", label:'${currentValue}°', backgroundColor: '#003CEC'
        }
        standardTile("refresh", "command.refresh", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "default", action:"refresh.refresh", icon:"st.secondary.refresh"
        }
        standardTile("configure", "device.configure", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "configure", label:'', action:"configuration.configure", icon:"st.secondary.configure"
        }
        standardTile("heatLevelUp", "device.heatLevelUp", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "heatLevelUp", label:'Heat', action:"heatLevelUp", icon:"st.thermostat.thermostat-up"
        }
        standardTile("heatLevelDown", "device.heatLevelDown", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "heatLevelDown", label:'Heat', action:"heatLevelDown", icon:"st.thermostat.thermostat-down"
        }
        standardTile("coolLevelUp", "device.coolLevelUp", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "coolLevelUp", label:'Cool', action:"coolLevelUp", icon:"st.thermostat.thermostat-up"
        }
        standardTile("coolLevelDown", "device.coolLevelDown", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "coolLevelDown", label:'Cool', action:"coolLevelDown", icon:"st.thermostat.thermostat-down"
        }
        valueTile("battery", "device.battery", width: 2, height: 2, inactiveLabel: false) {
            state "battery", label:'\n ${currentValue}%', unit: "", icon: "http://smartthings.rboyapps.com/images/battery.png", backgroundColors:[
                [value: 15, color: "#ff0000"],
                [value: 30, color: "#fd4e3a"],
                [value: 50, color: "#fda63a"],
                [value: 60, color: "#fdeb3a"],
                [value: 75, color: "#d4fd3a"],
                [value: 90, color: "#7cfd3a"],
                [value: 99, color: "#55fd3a"]
            ]
        }
        valueTile("humidity", "device.humidity", width: 2, height: 2, inactiveLabel: false) {
            state "humidity", label:'\n\n ${currentValue}%', icon:"st.Weather.weather12", backgroundColors: [
                [value: 20, color: "#ffe700"],
                [value: 30, color: "#d6ff00"],
                [value: 45, color: "#3cff00"],
                [value: 60, color: "#00ffb8"],
                [value: 80, color: "#00dfff"]
            ]
        }

        main "summary"
        details(["summary", "mode", "fanMode", "humidity", "heatingSetpoint", "heatLevelDown", "heatLevelUp", "heatSliderControl", "coolingSetpoint", "coolLevelDown", "coolLevelUp", "coolSliderControl", "refresh", "battery", "configure"])
    }
}

def updated() {
    log.trace "Update called settings: $settings"
    try {
        if (!state.init) {
            state.init = true
        }
        response(configure()) // Get the updates
    } catch (e) {
        log.warn "updated() threw $e"
    }
}

def parse(String description)
{
    def map = createEvent(zwaveEvent(zwave.parse(description, [0x42:1, 0x43:2, 0x31:3, 0x70:2])))
    if (!map) {
        return null
    }

    def result = [map]
    if (map.isStateChange && map.name in ["heatingSetpoint","coolingSetpoint","thermostatMode"]) {
        def map2 = [
            name: "thermostatSetpoint",
            unit: getTemperatureScale()
        ]
        if (map.name == "thermostatMode") {
            state.lastTriedMode = map.value
            if (map.value == "cool") {
                map2.value = device.latestValue("coolingSetpoint")
                log.info "THERMOSTAT, latest cooling setpoint = ${map2.value}"
            }
            else {
                map2.value = device.latestValue("heatingSetpoint")
                log.info "THERMOSTAT, latest heating setpoint = ${map2.value}"
            }
        }
        else {
            def mode = device.latestValue("thermostatMode")
            log.info "THERMOSTAT, latest mode = ${mode}"
            if ((map.name == "heatingSetpoint" && mode == "heat") || (map.name == "coolingSetpoint" && mode == "cool")) {
                map2.value = map.value
                map2.unit = map.unit
            }
        }
        if (map2.value != null) {
            log.debug "THERMOSTAT, adding setpoint event: $map"
            result << createEvent(map2)
        }
    } else if (map.name == "thermostatFanMode" && map.isStateChange) {
        state.lastTriedFanMode = map.value
    }

    def thermStatusS = "System ${device.currentState('thermostatOperatingState')?.value} | Fan ${device.currentState('thermostatFanState')?.value} | Battery ${device.currentState('battery')?.value}%"
    sendEvent("name": "thermStatus", "value": thermStatusS, displayed: false, isStateChange: true)
    log.trace thermStatusS

    log.debug "Parse returned $result"
    result
}

// Event Generation
def zwaveEvent(physicalgraph.zwave.commands.thermostatsetpointv2.ThermostatSetpointReport cmd)
{
    def cmdScale = cmd.scale == 1 ? "F" : "C"
    def map = [:]
    map.value = convertTemperatureIfNeeded(cmd.scaledValue, cmdScale, cmd.precision)
    map.unit = getTemperatureScale()
    map.displayed = true
    switch (cmd.setpointType) {
        case 1:
        map.name = "heatingSetpoint"
        break;
        case 2:
        map.name = "coolingSetpoint"
        break;
        default:
            return [:]
    }
    // So we can respond with same format
    state.size = cmd.size
    state.scale = cmd.scale
    state.precision = cmd.precision
    map
}

def zwaveEvent(physicalgraph.zwave.commands.sensormultilevelv3.SensorMultilevelReport cmd)
{
    def map = [:]
    map.displayed = true
    map.isStateChange = true
    if (cmd.sensorType == 1) {
        map.value = convertTemperatureIfNeeded(cmd.scaledSensorValue, cmd.scale == 1 ? "F" : "C", cmd.precision)
        map.unit = getTemperatureScale()
        map.name = "temperature"
    } else if (cmd.sensorType == 5) {
        map.value = cmd.scaledSensorValue
        map.unit = "%"
        map.name = "humidity"
    }
    map
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport cmd)
{
    def map = [:]
    switch (cmd.operatingState) {
        case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_IDLE:
        map.value = "idle"
        break
        case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_HEATING:
        map.value = "heating"
        break
        case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_COOLING:
        map.value = "cooling"
        break
        case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_FAN_ONLY:
        map.value = "fan only"
        break
        case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_PENDING_HEAT:
        map.value = "pending heat"
        break
        case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_PENDING_COOL:
        map.value = "pending cool"
        break
        case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_VENT_ECONOMIZER:
        map.value = "vent economizer"
        break
    }
    map.name = "thermostatOperatingState"
    map.displayed = true
    map.isStateChange = true
    map
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatfanstatev1.ThermostatFanStateReport cmd) {
    def map = [name: "thermostatFanState"]
    switch (cmd.fanOperatingState) {
        case 0:
        map.value = "idle"
        break
        case 1:
        map.value = "running"
        break
        case 2:
        map.value = "running high"
        break
    }
    map.displayed = true
    map.isStateChange = true
    map
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport cmd) {
    def map = [:]
    switch (cmd.mode) {
        case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_OFF:
        map.value = "off"
        break
        case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_HEAT:
        map.value = "heat"
        break
        case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_AUXILIARY_HEAT:
        map.value = "emergencyHeat"
        break
        case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_COOL:
        map.value = "cool"
        break
        case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_AUTO:
        map.value = "auto"
        break
    }
    map.name = "thermostatMode"
    map.displayed = true
    map
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeReport cmd) {
    def map = [:]
    switch (cmd.fanMode) {
        case physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeReport.FAN_MODE_AUTO_LOW:
        map.value = "fanAuto"
        break
        case physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeReport.FAN_MODE_LOW:
        map.value = "fanOn"
        break
        case physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeReport.FAN_MODE_CIRCULATION:
        map.value = "fanCirculate"
        break
    }
    map.name = "thermostatFanMode"
    map.displayed = true
    map
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeSupportedReport cmd) {
    log.trace "ThermostatModeSupportedReport: $cmd"

    def supportedModes = ""
    if(cmd.off) { supportedModes += "off " }
    if(cmd.heat) { supportedModes += "heat " }
    if(cmd.auxiliaryemergencyHeat) { supportedModes += "emergencyHeat " }
    if(cmd.cool) { supportedModes += "cool " }
    if(cmd.auto) { supportedModes += "auto " }

    log.trace "SuppportedModes: $supportedModes"

    state.supportedModes = supportedModes
    null // return null as there's nothing to process
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeSupportedReport cmd) {
    log.trace "ThermostatFanModeSupportedReport: $cmd"

    def supportedFanModes = ""
    if(cmd.auto) { supportedFanModes += "fanAuto " }
    if(cmd.low) { supportedFanModes += "fanOn " }
    if(cmd.circulation) { supportedFanModes += "fanCirculate " }

    log.trace "SuppportedFanModes: $supportedFanModes"

    state.supportedFanModes = supportedFanModes
    null // return null as there's nothing to process
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicReport cmd) {
    log.debug "Zwave event received: $cmd"
}

def zwaveEvent(physicalgraph.zwave.commands.versionv1.VersionReport cmd) {
    log.debug "$cmd"
	def fw = "${cmd.applicationVersion}.${cmd.applicationSubVersion}"
	updateDataValue("fw", fw)
	def text = "$device.displayName: firmware version: $fw, Z-Wave version: ${cmd.zWaveProtocolVersion}.${cmd.zWaveProtocolSubVersion}"
	def result = createEvent(descriptionText: text, isStateChange: false)
    
    if (state.MSR?.startsWith("0098-") && (cmd.applicationVersion <= 8)) {
        text = "Found CT-XXX thermostat model with defective v${cmd.applicationVersion} firmware. Clock functionality may be impaired"
        state.defectiveClock = true
        log.warn text
        result = createEvent(descriptionText: text, displayed: true)
    } else {
        state.defectiveClock = false // Reset incase the user upgraded the Z-Wave module
    }
    
    result
}
def zwaveEvent(physicalgraph.zwave.Command cmd) {
    log.warn "Unexpected zwave command $cmd"
}

// Command Implementations
def poll() {
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Z-Wave Thermostat with Temperature, Humidity and Auto Time Setting Device Handler"]) // Save DH Name for parent app

    def doPoll = false

    if (batterySaveMode) { // If we are in battery power save mode then we poll once it 30 minutes only
        log.debug "Battery save mode, fetching updates every 30 minutes"
        def nowTime = new Date().time
        def ageInMinutes = state.lastPollGet ? (nowTime - state.lastPollGet)/60000 : 30
        log.debug "Last poll ${ageInMinutes} minutes ago"
        if (ageInMinutes >= 30) {
            state.lastPollGet = nowTime
            log.info "Fetching fresh thermostate state"
            doPoll = true
        }
    } else {
        doPoll = true // no battery save, lets get the values
    }

    if (doPoll) {
        log.trace "Polling thermostat information"
        delayBetween([
            zwave.sensorMultilevelV3.sensorMultilevelGet().format(), // current temperature
            zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 1).format(),
            zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 2).format(),
            zwave.thermostatModeV2.thermostatModeGet().format(),
            zwave.thermostatFanModeV3.thermostatFanModeGet().format(),
            zwave.thermostatFanStateV1.thermostatFanStateGet().format(),
            zwave.thermostatOperatingStateV1.thermostatOperatingStateGet().format(),
            getBattery(),
            setClock(),
            zwave.multiInstanceV1.multiInstanceCmdEncap(instance: 2).encapsulate(zwave.sensorMultilevelV3.sensorMultilevelGet()).format() // CT-100/101 Customization - Humidity is an encapsulated multilevel sensor get command, 2nd instance
        ], 2300)
    }
    else {
        log.trace "Poll called again to soon, skipping poll to save battery"
        sendEvent(name: "battery", value: device.currentValue("battery"), unit: "%", descriptionText: "Battery save mode", displayed: false, isStateChange: true) // We need to send something otherwise Poll dies if nothing is done
        device.activity()  // workaround to keep polling from being shut off
        null
    }
}

def quickSetHeat(degrees) {
    setHeatingSetpoint(degrees, 1000)
}

def setHeatingSetpoint(degrees, delay = 30000) {
    setHeatingSetpoint(degrees.toDouble(), delay)
}

def setHeatingSetpoint(Double degrees, Integer delay = 30000) {
    log.trace "setHeatingSetpoint($degrees, $delay)"
    def deviceScale = state.scale ?: 1
    def deviceScaleString = deviceScale == 2 ? "C" : "F"
    def locationScale = getTemperatureScale()
    def p = (state.precision == null) ? 1 : state.precision

    def convertedDegrees
    if (locationScale == "C" && deviceScaleString == "F") {
        convertedDegrees = celsiusToFahrenheit(degrees)
    } else if (locationScale == "F" && deviceScaleString == "C") {
        convertedDegrees = fahrenheitToCelsius(degrees)
    } else {
        convertedDegrees = degrees
    }

    delayBetween([
        zwave.thermostatSetpointV1.thermostatSetpointSet(setpointType: 1, scale: deviceScale, precision: p, scaledValue: convertedDegrees).format(),
        zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 1).format()
    ], delay)
}

def quickSetCool(degrees) {
    setCoolingSetpoint(degrees, 1000)
}

def setCoolingSetpoint(degrees, delay = 30000) {
    setCoolingSetpoint(degrees.toDouble(), delay)
}

def setCoolingSetpoint(Double degrees, Integer delay = 30000) {
    log.trace "setCoolingSetpoint($degrees, $delay)"
    def deviceScale = state.scale ?: 1
    def deviceScaleString = deviceScale == 2 ? "C" : "F"
    def locationScale = getTemperatureScale()
    def p = (state.precision == null) ? 1 : state.precision

    def convertedDegrees
    if (locationScale == "C" && deviceScaleString == "F") {
        convertedDegrees = celsiusToFahrenheit(degrees)
    } else if (locationScale == "F" && deviceScaleString == "C") {
        convertedDegrees = fahrenheitToCelsius(degrees)
    } else {
        convertedDegrees = degrees
    }

    delayBetween([
        zwave.thermostatSetpointV1.thermostatSetpointSet(setpointType: 2, scale: deviceScale, precision: p,  scaledValue: convertedDegrees).format(),
        zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 2).format()
    ], delay)
}

def configure() {
    log.debug "Configure called"

    // Identify and configure the thermostat
    if (!state.MSR) { // If we don't have a MSR, first get it (and wait for it to complete)
        log.debug "Getting Device MSR"
        delayBetween([
            zwave.thermostatModeV2.thermostatModeSupportedGet().format(),
            zwave.thermostatFanModeV3.thermostatFanModeSupportedGet().format(),
            zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:[zwaveHubNodeId]).format(),
            zwave.manufacturerSpecificV2.manufacturerSpecificGet().format(),
            zwave.versionV1.versionGet().format()
        ], 2300)
    } else {
        log.trace "Device MSR: $state.MSR"
        checkThermostatModel()
        delayBetween([
            //discoverConfigParameters(), // DEBUGGING
            zwave.versionV1.versionGet().format(),
            zwave.thermostatModeV2.thermostatModeSupportedGet().format(),
            zwave.thermostatFanModeV3.thermostatFanModeSupportedGet().format(),
            zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:[zwaveHubNodeId]).format(),
            setConfigParameters()
        ], 2300)
    }
}

def modes() {
    ["off", "heat", "cool", "auto", "emergencyHeat"]
}

def switchMode() {
    def currentMode = device.currentState("thermostatMode")?.value
    def lastTriedMode = state.lastTriedMode ?: currentMode ?: "off"
    def supportedModes = getDataByName("supportedModes")
    def modeOrder = modes()
    def next = { modeOrder[modeOrder.indexOf(it) + 1] ?: modeOrder[0] }
    def nextMode = next(lastTriedMode)
    if (supportedModes?.contains(currentMode)) {
        while (!supportedModes.contains(nextMode) && nextMode != "off") {
            nextMode = next(nextMode)
        }
    }
    state.lastTriedMode = nextMode
    delayBetween([
        zwave.thermostatModeV2.thermostatModeSet(mode: modeMap[nextMode]).format(),
        zwave.thermostatModeV2.thermostatModeGet().format()
    ], 1000)
}

def switchToMode(nextMode) {
    def supportedModes = getDataByName("supportedModes")
    if(supportedModes && !supportedModes.contains(nextMode)) log.warn "thermostat mode '$nextMode' is not supported"
    if (nextMode in modes()) {
        state.lastTriedMode = nextMode
        "$nextMode"()
    } else {
        log.debug("no mode method '$nextMode'")
    }
}

def switchFanMode() {
    def currentMode = device.currentState("thermostatFanMode")?.value
    def lastTriedMode = state.lastTriedFanMode ?: currentMode ?: "off"
    def supportedModes = getDataByName("supportedFanModes") ?: "fanAuto fanOn"
    def modeOrder = ["fanAuto", "fanCirculate", "fanOn"]
    def next = { modeOrder[modeOrder.indexOf(it) + 1] ?: modeOrder[0] }
    def nextMode = next(lastTriedMode)
    while (!supportedModes?.contains(nextMode) && nextMode != "fanAuto") {
        nextMode = next(nextMode)
    }
    switchToFanMode(nextMode)
}

def switchToFanMode(nextMode) {
    def supportedFanModes = getDataByName("supportedFanModes")
    if(supportedFanModes && !supportedFanModes.contains(nextMode)) log.warn "thermostat mode '$nextMode' is not supported"

    def returnCommand
    if (nextMode == "fanAuto") {
        returnCommand = fanAuto()
    } else if (nextMode == "fanOn") {
        returnCommand = fanOn()
    } else if (nextMode == "fanCirculate") {
        returnCommand = fanCirculate()
    } else {
        log.debug("no fan mode '$nextMode'")
    }
    if(returnCommand) state.lastTriedFanMode = nextMode
    returnCommand
}

def getDataByName(String name) {
    state[name] ?: device.getDataValue(name)
}

def getModeMap() { [
    "off": 0,
    "heat": 1,
    "cool": 2,
    "auto": 3,
    "emergencyHeat": 4
]}

def setThermostatMode(String value) {
    delayBetween([
        zwave.thermostatModeV2.thermostatModeSet(mode: modeMap[value]).format(),
        zwave.thermostatModeV2.thermostatModeGet().format()
    ], standardDelay)
}

def getFanModeMap() { [
    "auto": 0,
    "on": 1,
    "circulate": 6
]}

def setThermostatFanMode(String value) {
    delayBetween([
        zwave.thermostatFanModeV3.thermostatFanModeSet(fanMode: fanModeMap[value]).format(),
        zwave.thermostatFanModeV3.thermostatFanModeGet().format()
    ], standardDelay)
}

def off() {
    delayBetween([
        zwave.thermostatModeV2.thermostatModeSet(mode: 0).format(),
        zwave.thermostatModeV2.thermostatModeGet().format()
    ], standardDelay)
}

def heat() {
    delayBetween([
        zwave.thermostatModeV2.thermostatModeSet(mode: 1).format(),
        zwave.thermostatModeV2.thermostatModeGet().format()
    ], standardDelay)
}

def emergencyHeat() {
    delayBetween([
        zwave.thermostatModeV2.thermostatModeSet(mode: 4).format(),
        zwave.thermostatModeV2.thermostatModeGet().format()
    ], standardDelay)
}

def cool() {
    delayBetween([
        zwave.thermostatModeV2.thermostatModeSet(mode: 2).format(),
        zwave.thermostatModeV2.thermostatModeGet().format()
    ], standardDelay)
}

def auto() {
    delayBetween([
        zwave.thermostatModeV2.thermostatModeSet(mode: 3).format(),
        zwave.thermostatModeV2.thermostatModeGet().format()
    ], standardDelay)
}

def fanOn() {
    delayBetween([
        zwave.thermostatFanModeV3.thermostatFanModeSet(fanMode: 1).format(),
        zwave.thermostatFanModeV3.thermostatFanModeGet().format()
    ], standardDelay)
}

def fanAuto() {
    delayBetween([
        zwave.thermostatFanModeV3.thermostatFanModeSet(fanMode: 0).format(),
        zwave.thermostatFanModeV3.thermostatFanModeGet().format()
    ], standardDelay)
}

def fanCirculate() {
    delayBetween([
        zwave.thermostatFanModeV3.thermostatFanModeSet(fanMode: 6).format(),
        zwave.thermostatFanModeV3.thermostatFanModeGet().format()
    ], standardDelay)
}

private getStandardDelay() {
    1000
}

def zwaveEvent(physicalgraph.zwave.commands.multichannelv3.MultiInstanceCmdEncap cmd) {
    def encapsulatedCommand = cmd?.encapsulatedCommand([0x31: 3]) // Encapsulate Sensor Multi Level (0x31) and use Version 3 of the class
    log.debug ("multichannelv3.MultiInstanceCmdEncap: command from instance ${cmd?.instance}: ${encapsulatedCommand}")
    if (encapsulatedCommand) {
        return zwaveEvent(encapsulatedCommand)
    } else {
        log.warn "multichannelv3.MultiInstanceCmdEncap: unrecognized command $cmd"
    }
}

def zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport cmd) {
    def map = [ name: "battery", unit: "%" ]
    map.isStateChange = true
    map.displayed = true
    log.debug "Battery level $cmd.batteryLevel%"
    if (cmd.batteryLevel == 0xFF || cmd.batteryLevel == 0) {
        map.value = 1
        map.descriptionText = "battery is low!"
    } else {
        map.value = cmd.batteryLevel
    }
    map
}

def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd) {
    log.debug "ManufacturerSpecificReport $cmd"
    def result = []

    def msr = String.format("%04X-%04X-%04X", cmd.manufacturerId, cmd.productTypeId, cmd.productId)
    log.debug "msr: $msr"
    updateDataValue("MSR", msr)

    result << createEvent(descriptionText: "$device.displayName MSR: $msr", isStateChange: false)
    result
}

def zwaveEvent(physicalgraph.zwave.commands.configurationv2.ConfigurationReport cmd) {
    log.trace "ConfigurationReport: $cmd"

    switch (state.MSR) {
        case "5254-0200-8031": // ZTS-110
        switch (cmd.parameterNumber) {
            case 1:
            log.trace "Current Temperature Swing: ${(cmd.configurationValue[0] & 0x7)}.0°F" // Max value is 4 in increments of 1.0°F (filter the rest out)
            sendEvent(name:"temperatureSwing", value:"${(cmd.configurationValue[0] & 0x7)}.0°F", displayed: true)
            break

            case 11:
            log.trace "Current Auto Temperature Change Report: ${cmd.configurationValue[0] & 0xF}.0°F" // Max value is 8 in increments of 1.0°F (filter the rest out)
            sendEvent(name:"temperatureChangeReport", value:"${cmd.configurationValue[0] & 0xF}.0°F", displayed: true)
            break

            case 13:
            log.trace "Current Temperature Calibration Correction: ${cmd.configurationValue[0] as byte}.0°F" // See docs
            sendEvent(name:"temperatureCalibration", value:"${cmd.configurationValue[0] as byte}.0°F", displayed: true)
            break

            default:
                break    
        }
        break

        case ~/0098-.*/: // CT-XXX
        switch (cmd.parameterNumber) {
            case 1:
            log.trace "Current Auto Temperature Change Report: ${(cmd.configurationValue[0] & 0x7) * 0.5}°F" // Max value is 4 in increments of 0.5°F (filter the rest out)
            sendEvent(name:"temperatureChangeReport", value:"${(cmd.configurationValue[0] & 0x7) * 0.5}°F", displayed: true)
            break

            case 7:
            log.trace "Current Temperature Swing: ${(cmd.configurationValue[0] & 0xF) * 0.5}°F" // Max value is 8 in increments of 0.5°F (filter the rest out)
            sendEvent(name:"temperatureSwing", value:"${(cmd.configurationValue[0] & 0xF) * 0.5}°F", displayed: true)
            break

            default:
                break    
        }
        break

        default:
            break
    }

    null // Just info, nothing to do
}

private checkThermostatModel() {
    switch (state.MSR) {
        case "5254-0200-8031": // ZTS-110
        log.debug "Found ZTS-110 Thermostat"
        sendEvent(name:"thermostatModel", value:"ZTS-110", displayed: true)
        break

        case "0098-6401-0107": //CT-100
        case "0098-6401-0106": //CT-100 Vivint
        log.debug "Found CT-100 Thermostat"
        sendEvent(name:"thermostatModel", value:"CT-100", displayed: true)
        break

        case "0098-6501-000C": //CT-101 (lowe's model)
        log.debug "Found CT-101 Thermostat"
        sendEvent(name:"thermostatModel", value:"CT-101", displayed: true)
        break

        case "0098-1E10-0158": //CT-30
        case "0098-1E12-015C": //CT-30e
        case "0098-0000-0000": //CT-30 (local alarm company model)
        case "0098-1E12-015E": //CT-30 Rev C1
        case "0098-0001-001E": //CT-30 APX
        log.debug "Found CT-30 Thermostat"
        sendEvent(name:"thermostatModel", value:"CT-30", displayed: true)
        break

        default:
            log.debug "Unknown thermostat with MSR $state.MSR"
        sendEvent(name:"thermostatModel", value:"Unknown thermostat with MSR $state.MSR", displayed: true)
        break
    }
}

private getBattery() {	//once every 24 hours
    def nowTime = new Date().time
    def ageInMinutes = state.lastBatteryGet ? (nowTime - state.lastBatteryGet)/60000 : 1440
    log.debug "Battery report age: ${ageInMinutes} minutes"
    if (ageInMinutes >= 1440) {
        state.lastBatteryGet = nowTime
        log.debug "Fetching fresh battery value"
        zwave.batteryV1.batteryGet().format()
    } else "delay 87"
}

private setClock() {	// once a day
    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        log.error "Hub timeZone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
        sendEvent(name: "InvalidTimezone", value: "InvalidTimezone", descriptionText: "Hub timeZone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately", isStateChange: true, displayed: true)
    }

    def nowTime = new Date().time
    def ageInMinutes = state.lastClockSet ? (nowTime - state.lastClockSet)/60000 : 1440
    log.debug "Clock set age: ${ageInMinutes} minutes"
    if (ageInMinutes >= 1440) {
        state.lastClockSet = nowTime
        def nowCal = Calendar.getInstance(timeZone) // get current location timezone
        if (state.defectiveClock) {
            log.warn "Found CT-XXX with defective firmware, setting clock in day into the past"
            nowCal.add(Calendar.DAY_OF_MONTH, -1) // the thermostat with defective firmware shows it one day into the future to send one day in the past to get correct day
        }
        log.debug "Setting clock to ${nowCal.getTime().format("EEE MMM dd yyyy HH:mm:ss z", timeZone)}"
        sendEvent(name: "SetClock", value: "setting clock to ${nowCal.getTime().format("EEE MMM dd yyyy HH:mm:ss z", timeZone)}", displayed: true)
        zwave.clockV1.clockSet(hour: nowCal.get(Calendar.HOUR_OF_DAY), minute: nowCal.get(Calendar.MINUTE), weekday: nowCal.get(Calendar.DAY_OF_WEEK)).format()
    } else "delay 87"
}

def refresh() {
    // Force a refresh
    log.info "Requested a refresh"
    state.lastBatteryGet = (new Date().time) - (1440 * 60000)
    state.lastClockSet = (new Date().time) - (1440 * 60000)
    state.lastPollGet = (new Date().time) - (30 * 60000)

    // Identify and configure the thermostat
    if (!state.MSR) { // If we don't have a MSR, first get it (and wait for it to complete)
        log.debug "Getting Device MSR"
        delayBetween([
            zwave.manufacturerSpecificV2.manufacturerSpecificGet().format(),
            zwave.versionV1.versionGet().format(),
            poll()
        ], 2000)
    } else {
        log.trace "Device MSR: $state.MSR"
        delayBetween([
            poll()
        ], 2000)
    }

    // NOTHING AFTER THIS AS THE ZWAVE NEEDS TO BE RETURNED TO BE EXECUTED
}

def setConfigParameters() {
    def cmds = []
    switch (state.MSR) {
        case "5254-0200-8031": // ZTS-110
        if (settings.autoTempDiffZTS) {
            log.debug "Setting new value of Auto Temp Change Report to $settings.autoTempDiffZTS"
            def paramValue
            switch (settings.autoTempDiffZTS) {
                case "Disabled":
                paramValue = 0
                break
                case "1.0°F":
                paramValue = 1
                break
                case "2.0°F":
                paramValue = 2
                break
                case "3.0°F":
                paramValue = 3
                break
                case "4.0°F":
                paramValue = 4
                break
                case "5.0°F":
                paramValue = 5
                break
                case "6.0°F":
                paramValue = 6
                break
                case "7.0°F":
                paramValue = 7
                break
                case "8.0°F":
                paramValue = 8
                break
                default:
                    paramValue = 4 // Default 4.0°F
                break
            }

            cmds << zwave.configurationV2.configurationGet(parameterNumber: 11).format() // Check before
            cmds << zwave.configurationV2.configurationSet(parameterNumber: 11, size: 1, configurationValue: [paramValue]).format()
            cmds << zwave.configurationV2.configurationGet(parameterNumber: 11).format() // Verify after
        }

        if (settings.tempCalibrationZTS) {
            log.debug "Setting new value of Temperature Calibration to $settings.tempCalibrationZTS"
            def paramValue
            switch (settings.tempCalibrationZTS) {
                case "-10°F":
                paramValue = 0xF6
                break
                case "-9°F":
                paramValue = 0xF7
                break
                case "-8°F":
                paramValue = 0xF8
                break
                case "-7°F":
                paramValue = 0xF9
                break
                case "-6°F":
                paramValue = 0xFA
                break
                case "-5°F":
                paramValue = 0xFB
                break
                case "-4°F":
                paramValue = 0xFC
                break
                case "-3°F":
                paramValue = 0xFD
                break
                case "-2°F":
                paramValue = 0xFE
                break
                case "-1°F":
                paramValue = 0xFF
                break
                case "0°F":
                paramValue = 0
                break
                case "1°F":
                paramValue = 0x01
                break
                case "2°F":
                paramValue = 0x02
                break
                case "3°F":
                paramValue = 0x03
                break
                case "4°F":
                paramValue = 0x04
                break
                case "5°F":
                paramValue = 0x05
                break
                case "6°F":
                paramValue = 0x06
                break
                case "7°F":
                paramValue = 0x07
                break
                case "8°F":
                paramValue = 0x08
                break
                case "9°F":
                paramValue = 0x09
                break
                case "10°F":
                paramValue = 0x0A
                break
                default:
                    paramValue = 0 // Default 0°F
                break
            }

            cmds << zwave.configurationV2.configurationGet(parameterNumber: 13).format() // Check before
            cmds << zwave.configurationV2.configurationSet(parameterNumber: 13, size: 1, configurationValue: [paramValue]).format()
            cmds << zwave.configurationV2.configurationGet(parameterNumber: 13).format() // Verify after
        }

        if (settings.swingZTS) {
            log.debug "Setting new value of Temp Swing to $settings.swingZTS"
            def paramValue
            switch (settings.swingZTS) {
                case "1.0°F":
                paramValue = 1
                break
                case "2.0°F":
                paramValue = 2
                break
                case "3.0°F":
                paramValue = 3
                break
                case "4.0°F":
                paramValue = 4
                break
                default:
                    paramValue = 2 // Default 2.0°F
                break
            }

            cmds << zwave.configurationV2.configurationGet(parameterNumber: 1).format() // Check before
            cmds << zwave.configurationV2.configurationSet(parameterNumber: 1, size: 1, configurationValue: [paramValue]).format()
            cmds << zwave.configurationV2.configurationGet(parameterNumber: 1).format() // Verify after
        }
        break

        case ~/0098-.*/: // CT-XXX
        if (settings.autoTempDiffCT) {
            log.debug "Setting new value of Auto Temp Differential Report to $settings.autoTempDiffCT"
            def paramValue
            switch (settings.autoTempDiffCT) {
                case "Disabled":
                paramValue = 0
                break
                case "0.5°F":
                paramValue = 1
                break
                case "1.0°F":
                paramValue = 2
                break
                case "1.5°F":
                paramValue = 3
                break
                case "2.0°F":
                paramValue = 4
                break
                default:
                    paramValue = 2 // Default 1.0°F
                break
            }

            cmds << zwave.configurationV2.configurationGet(parameterNumber: 1).format() // Check before
            cmds << zwave.configurationV2.configurationSet(parameterNumber: 1, size: 1, configurationValue: [paramValue]).format()
            cmds << zwave.configurationV2.configurationGet(parameterNumber: 1).format() // Verify after
        }

        if (settings.swingCT) {
            log.debug "Setting new value of Temp Swing to $settings.swingCT"
            def paramValue
            switch (settings.swingCT) {
                case "0.5°F":
                paramValue = 1
                break
                case "1.0°F":
                paramValue = 2
                break
                case "1.5°F":
                paramValue = 3
                break
                case "2.0°F":
                paramValue = 4
                break
                case "2.5°F":
                paramValue = 5
                break
                case "3.0°F":
                paramValue = 6
                break
                case "3.5°F":
                paramValue = 7
                break
                case "4.0°F":
                paramValue = 8
                break
                default:
                    paramValue = 2 // Default 1.0°F
                break
            }

            cmds << zwave.configurationV2.configurationGet(parameterNumber: 7).format() // Check before
            cmds << zwave.configurationV2.configurationSet(parameterNumber: 7, size: 1, configurationValue: [paramValue]).format()
            cmds << zwave.configurationV2.configurationGet(parameterNumber: 7).format() // Verify after
        }
        break

        default:
            break
    }

    if (cmds) {
        delayBetween(cmds, 2000)
    } else {
        null
    }
}

def discoverConfigParameters() {
    log.trace "Discovering the first 15 configuration parameters"

    def cmds = []
    (1..15).each { param ->
        cmds << zwave.configurationV2.configurationGet(parameterNumber: param).format() // Check before
    }
    delayBetween(cmds, 2000)
}

def coolLevelUp() {
    def locationScale = getTemperatureScale()
    def maxTemp
    def minTemp
    if (locationScale == "C") {
        maxTemp = 37 // Max Temp in C
        minTemp = 1 // Min Temp in C
        log.trace "Location is in Celsius, MaxTemp $maxTemp, MinTemp $minTemp"
    } else {
        maxTemp = 99 // Max temp in F
        minTemp = 35 // Max temp in F
        log.trace "Location is in Farenheit, MaxTemp $maxTemp, MinTemp $minTemp"
    }

    int nextLevel = device.currentValue("coolingSetpoint") + 1

    if( nextLevel > maxTemp) {
        nextLevel = maxTemp
    }
    log.debug "Setting cool set point up to: ${nextLevel}"
    quickSetCool(nextLevel)
}

def coolLevelDown() {
    def locationScale = getTemperatureScale()
    def maxTemp
    def minTemp
    if (locationScale == "C") {
        maxTemp = 37 // Max Temp in C
        minTemp = 1 // Min Temp in C
        log.trace "Location is in Celsius, MaxTemp $maxTemp, MinTemp $minTemp"
    } else {
        maxTemp = 99 // Max temp in F
        minTemp = 35 // Max temp in F
        log.trace "Location is in Farenheit, MaxTemp $maxTemp, MinTemp $minTemp"
    }

    int nextLevel = device.currentValue("coolingSetpoint") - 1

    if( nextLevel < minTemp) {
        nextLevel = minTemp
    }
    log.debug "Setting cool set point down to: ${nextLevel}"
    quickSetCool(nextLevel)
}

def heatLevelUp() {
    def locationScale = getTemperatureScale()
    def maxTemp
    def minTemp
    if (locationScale == "C") {
        maxTemp = 37 // Max Temp in C
        minTemp = 1 // Min Temp in C
        log.trace "Location is in Celsius, MaxTemp $maxTemp, MinTemp $minTemp"
    } else {
        maxTemp = 99 // Max temp in F
        minTemp = 35 // Max temp in F
        log.trace "Location is in Farenheit, MaxTemp $maxTemp, MinTemp $minTemp"
    }

    int nextLevel = device.currentValue("heatingSetpoint") + 1

    if( nextLevel > maxTemp) {
        nextLevel = maxTemp
    }
    log.debug "Setting heat set point up to: ${nextLevel}"
    quickSetHeat(nextLevel)
}

def heatLevelDown() {
    def locationScale = getTemperatureScale()
    def maxTemp
    def minTemp
    if (locationScale == "C") {
        maxTemp = 37 // Max Temp in C
        minTemp = 1 // Min Temp in C
        log.trace "Location is in Celsius, MaxTemp $maxTemp, MinTemp $minTemp"
    } else {
        maxTemp = 99 // Max temp in F
        minTemp = 35 // Max temp in F
        log.trace "Location is in Farenheit, MaxTemp $maxTemp, MinTemp $minTemp"
    }

    int nextLevel = device.currentValue("heatingSetpoint") - 1

    if( nextLevel < minTemp) {
        nextLevel = minTemp
    }
    log.debug "Setting heat set point down to: ${nextLevel}"
    quickSetHeat(nextLevel)
}

def levelUp() {
    log.trace "Level Up called"
    levelUpDown(1)
}

def levelDown() {
    log.trace "Level Down called"
    levelUpDown(-1)
}

def levelUpDown(value) {
    log.trace "levelUpDown called with value $value, current thermostat mode ${device.currentState("thermostatMode")?.value}"

    // NOTE: Bug in ST platform, for iOS devices we only get 0 (down) and 1 (up) for this control
    // For Android devices we get an absolute number showing the number of times up/down have been called since the page was opened (e.g. called up 4 times we get +4, if down then we get +3). If you open the page again and press up you get +1, if you close and open again and press down you get -1 (and the as long as the page is open it will be cumulative)

    // Determine which OS based on value behaviors (urrgghhh.....ST!)
    def upLevel
    if (!state.lastLevelUpDown)
    state.lastLevelUpDown = 0 // If it isn't defined lets baseline it

    if ((state.lastLevelUpDown == 1) && (value == 1)) // Last time it was 1 and again it's 1 its increase
    upLevel = true
    else if ((state.lastLevelUpDown == 0) && (value == 0)) // Last time it was 0 and again it's 0 then it's decrease
        upLevel = false
    else if ((state.lastLevelUpDown == -1) && (value == -1)) // Last time it was -1 and again it's -1 then it's decrease
        upLevel = false
    else if ((value - state.lastLevelUpDown) > 0) // If it's increasing then it's up
        upLevel = true
    else if ((value - state.lastLevelUpDown) < 0) // If it's decreasing then it's down
        upLevel = false
    else
        log.error "UNDEFINED STATE, CONTACT DEVELOPER. Last level $state.lastLevelUpDown, Current level, $value"

    state.lastLevelUpDown = value // Save it

    if (upLevel) { // Increase the current temperature (check heating or cooling mode)
        log.debug "Increasing temperature by 1°"
        if (device.currentState("thermostatMode")?.value.contains("auto")) { // Auto we dont' know current mode, so change heat and cool
            delayBetween([heatLevelUp(), coolLevelUp()], 5000)
        } else if (device.currentState("thermostatMode")?.value.contains("heat")) {
            heatLevelUp()
        } else if (device.currentState("thermostatMode")?.value.contains("cool")) {
            coolLevelUp()
        }
    } else {
        log.debug "Reducing temperature by 1°"
        if (device.currentState("thermostatMode")?.value.contains("auto")) { // Auto we dont' know current mode, so change heat and cool
            delayBetween([heatLevelDown(), coolLevelDown()], 5000)
        } else if (device.currentState("thermostatMode")?.value.contains("heat")) {
            heatLevelDown()
        } else if (device.currentState("thermostatMode")?.value.contains("cool")) {
            coolLevelDown()
        }
    }

    // NOTHING AFTER THE COMMANDS OR THE COMMANDS WONT WORK
}